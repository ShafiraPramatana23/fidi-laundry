package com.fidilaundry.app.ui.home.orderimport android.Manifestimport android.content.Intentimport android.content.pm.PackageManagerimport android.location.Geocoderimport android.os.Bundleimport android.widget.Toastimport androidx.annotation.NonNullimport androidx.core.app.ActivityCompatimport androidx.lifecycle.Observerimport com.fidilaundry.app.Rimport com.fidilaundry.app.basearch.viewmodel.OrderViewModelimport com.fidilaundry.app.databinding.ActivityOrderUserBindingimport com.fidilaundry.app.model.request.OrderRequestimport com.fidilaundry.app.model.request.SaveNotifRequestimport com.fidilaundry.app.model.request.SendNotifRequestimport com.fidilaundry.app.model.response.BaseObjResponseimport com.fidilaundry.app.model.response.ItemListResponseimport com.fidilaundry.app.model.response.ProfileResponseimport com.fidilaundry.app.model.response.RequestOrderResponseimport com.fidilaundry.app.ui.base.BaseActivityimport com.fidilaundry.app.util.Constantimport com.fidilaundry.app.util.LoadingDialogimport com.fidilaundry.app.util.fdialog.ConfirmMessageimport com.fidilaundry.app.util.fdialog.ErrorMessageimport com.fidilaundry.app.util.fdialog.FGCallbackimport com.fidilaundry.app.util.fdialog.WarningMessageimport com.fidilaundry.app.util.setSafeOnClickListenerimport com.google.android.gms.location.FusedLocationProviderClientimport com.google.android.gms.location.LocationServicesimport com.mapbox.api.directions.v5.DirectionsCriteriaimport com.mapbox.api.directions.v5.MapboxDirectionsimport com.mapbox.api.directions.v5.models.DirectionsResponseimport com.mapbox.core.constants.Constantsimport com.mapbox.geojson.LineStringimport com.mapbox.geojson.Pointimport com.mapbox.mapboxsdk.Mapboximport com.mapbox.mapboxsdk.annotations.MarkerOptionsimport com.mapbox.mapboxsdk.camera.CameraPositionimport com.mapbox.mapboxsdk.camera.CameraUpdateFactoryimport com.mapbox.mapboxsdk.geometry.LatLngimport com.mapbox.mapboxsdk.maps.MapboxMapimport com.mapbox.mapboxsdk.maps.OnMapReadyCallbackimport com.mapbox.mapboxsdk.maps.Styleimport com.mapbox.mapboxsdk.style.sources.GeoJsonSourceimport org.koin.androidx.viewmodel.ext.android.getViewModelimport retrofit2.Callimport retrofit2.Callbackimport retrofit2.Responseimport timber.log.Timberimport java.util.concurrent.TimeUnitclass UserOrderActivity : BaseActivity() {    lateinit var loadingDialog: LoadingDialog    lateinit var client: MapboxDirections    private var idService: Int = 0    private var profileData: ProfileResponse.Results? = null    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient    private var longitude = 0.0    private var latitude = 0.0    private var address = ""    private var orderCode = ""    private var distance = 0.0    private var dtOrder: ItemListResponse.Result? = null    private val binding: ActivityOrderUserBinding by binding(R.layout.activity_order_user)    private val viewModel: OrderViewModel by lazy {        getViewModel(OrderViewModel::class)    }    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Mapbox.getInstance(applicationContext, getString(R.string.mapbox_access_token))        binding.apply {            lifecycleOwner = this@UserOrderActivity            this.vm = viewModel        }        loadingDialog = LoadingDialog()        idService = intent.getIntExtra("idService", 0)        profileData = paperPref.getDataProfile()        initViewModel()        viewModel.getItemsByService(idService)        fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this)        checkPermission()        binding.mapView.onCreate(savedInstanceState)        binding.btnOrder.setSafeOnClickListener {            if (distance > 5000) {                ErrorMessage(this@UserOrderActivity, "", "Mohon maaf Anda tidak dapat melakukan pemesanan, jarak melebihi 5 km dari FIDI Laundry.")            } else {                dialogConfirm()            }        }        binding.ivBack.setSafeOnClickListener {            finish()        }    }    private fun initMaps() {        binding.mapView.getMapAsync(object : OnMapReadyCallback {            override fun onMapReady(@NonNull mbMap: MapboxMap) {                mbMap.setStyle(                    Style.MAPBOX_STREETS,                    Style.OnStyleLoaded { style ->                        val mOptions = MarkerOptions()                        mOptions.title("Current Position")                        mOptions.position(LatLng(latitude, longitude))                        mbMap.addMarker(mOptions)                        val pstn = CameraPosition.Builder()                            .target(LatLng(latitude, longitude))                            .zoom(10.0)                            .tilt(20.0)                            .build()                        mbMap.animateCamera(                            CameraUpdateFactory.newCameraPosition(pstn),                            1000                        )                    })            }        })    }    private fun checkPermission() {        if (ActivityCompat.checkSelfPermission(                this,                Manifest.permission.ACCESS_FINE_LOCATION            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(                this,                Manifest.permission.ACCESS_COARSE_LOCATION            ) != PackageManager.PERMISSION_GRANTED        ) {            ActivityCompat.requestPermissions(                this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),                1            )            return        } else {            fusedLocationProviderClient.lastLocation.addOnSuccessListener { location ->                if (location != null) {                    val geoCoder = Geocoder(this)                    val currentLocation = geoCoder.getFromLocation(                        location.latitude,                        location.longitude,                        1                    )                    latitude = currentLocation?.first()?.latitude!!                    longitude = currentLocation?.first()?.longitude!!                    address = currentLocation?.first()?.getAddressLine(0)!!                    binding.tvAddress.text = address                    initMaps()                    var origin = Point.fromLngLat(longitude, latitude)                    var destination = Point.fromLngLat(Constant.LONG_LAUNDRY, Constant.LAT_LAUNDRY) //laundry                    getRoute(origin, destination)                }            }        }    }    private fun getRoute(origin: Point, destination: Point) {        client = MapboxDirections.builder()            .origin(origin)            .destination(destination)            .overview(DirectionsCriteria.OVERVIEW_FULL)            .profile(DirectionsCriteria.PROFILE_DRIVING)            .accessToken(getString(R.string.mapbox_access_token))            .build()        client.enqueueCall(object : Callback<DirectionsResponse?> {            override fun onResponse(                call: Call<DirectionsResponse?>,                response: Response<DirectionsResponse?>            ) {                Timber.d("Response code: " + response.code())                if (response.body() == null) {                    Timber.e("No routes found, make sure you set the right user and access token.")                    return                } else if (response.body()!!.routes().size < 1) {                    Timber.e("No routes found")                    return                }                distance = response.body()!!.routes().get(0).distance()                WarningMessage(this@UserOrderActivity, "", distance.toString())            }            override fun onFailure(call: Call<DirectionsResponse?>, t: Throwable) {                print("Get distance error : "+t.message)            }        })    }    private fun initViewModel() {        viewModel.itemsListResponse.observe(this, Observer {            handleWhenItemListSuccess(it)        })        viewModel.orderResponse.observe(this, Observer {            handleWhenReqOrderSuccess(it)        })        viewModel.sendNotifResponse.observe(this, Observer {            handleWhenSendNotifSuccess(it)        })        viewModel.showProgressLiveData.observe(this, Observer { showLoading ->            if (showLoading) {                if (loadingDialog != null) {                    if (!loadingDialog.isShowLoad())                        loadingDialog.showProgressDialog(this, "Mohon tunggu…")                    else {                        loadingDialog.dismissDialog()                        loadingDialog.showProgressDialog(this, "Mohon tunggu…")                    }                }            } else {                loadingDialog.dismissDialog()            }        })        viewModel.showError.observe(this, Observer { showError ->            when (showError) {                "errSendNotif" -> {                    val intent = Intent(baseContext, OrderMapsActivity::class.java)                    intent.putExtra("orderId", viewModel.orderResponse.value?.results?.orderId)                    intent.putExtra("orderCode", orderCode)                    startActivity(intent)                    finish()                }                else -> ErrorMessage(this, "", showError)            }        })    }    private fun handleWhenSendNotifSuccess(it: BaseObjResponse?) {        /*viewModel.saveNotif(SaveNotifRequest(            2,            viewModel.orderResponse.value?.results?.orderId!!,            "(Pesanan Baru) ${dtOrder?.serviceTitle} dari pelanggan ${profileData?.name}"        ))*/        val intent = Intent(baseContext, OrderMapsActivity::class.java)        intent.putExtra("orderId", viewModel.orderResponse.value?.results?.orderId)        intent.putExtra("orderCode", orderCode)        startActivity(intent)        finish()    }    private fun handleWhenReqOrderSuccess(it: RequestOrderResponse?) {        orderCode = it?.results?.orderCode!!        viewModel.sendNotif(            SendNotifRequest(                "Pesanan Baru", 2,                "(Pesanan Baru) ${dtOrder?.serviceTitle} dari pelanggan ${profileData?.name}",                it?.results?.orderId!!            )        )    }    private fun handleWhenItemListSuccess(it: ItemListResponse?) {        var dt = it?.results?.filter { it.categoryID == "2" }        dtOrder = dt?.get(0)        binding.tvDesc.text =            "Harga ${dt?.get(0)?.serviceTitle} Rp. ${dt?.get(0)?.price}/kg. Update harga akan dilakukan oleh petugas\n" +                    "setelah menimbang dan menyortir baju."        binding.tvType.text = dt?.get(0)?.serviceTitle        binding.tvName.text = profileData?.name    }    private fun dialogConfirm() {        ConfirmMessage(            this, "Apakah rincian pesanan Anda sudah benar?",            "", "", "Lanjutkan", "Batal",            object : FGCallback {                override fun onCallback() {                    var id = profileData?.id                    viewModel.requestOrder(                        OrderRequest(                            idService, latitude.toString(), longitude.toString(),                            address, "Antar Jemput", id!!, id!!                        )                    )                }            }        )    }    override fun onRequestPermissionsResult(        requestCode: Int,        permissions: Array<String?>,        grantResults: IntArray    ) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults)        if (requestCode == 1) {            checkPermission()        }    }    override fun onStart() {        super.onStart()        binding.mapView.onStart()    }    override fun onStop() {        super.onStop()        binding.mapView.onStop()    }    override fun onLowMemory() {        super.onLowMemory()        binding.mapView.onLowMemory()    }    override fun onDestroy() {        super.onDestroy()        binding.mapView.onDestroy()    }}