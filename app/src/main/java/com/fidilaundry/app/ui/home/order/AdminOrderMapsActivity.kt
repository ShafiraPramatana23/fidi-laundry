package com.fidilaundry.app.ui.home.orderimport android.Manifestimport android.content.Intentimport android.content.pm.PackageManagerimport android.graphics.Colorimport android.location.Geocoderimport android.os.Bundleimport android.widget.Toastimport androidx.annotation.NonNullimport androidx.core.app.ActivityCompatimport androidx.lifecycle.Observerimport com.fidilaundry.app.Rimport com.fidilaundry.app.basearch.viewmodel.TrackingViewModelimport com.fidilaundry.app.databinding.ActivityAdminOrderMapsBindingimport com.fidilaundry.app.model.request.AddTrackingRequestimport com.fidilaundry.app.model.request.UpdateOrderStatusRequestimport com.fidilaundry.app.model.response.BaseResponseimport com.fidilaundry.app.model.response.OrderListResponseimport com.fidilaundry.app.model.response.UpdateStatusResponseimport com.fidilaundry.app.ui.base.BaseActivityimport com.fidilaundry.app.util.LoadingDialogimport com.fidilaundry.app.util.StatusHelperimport com.fidilaundry.app.util.fdialog.ErrorMessageimport com.fidilaundry.app.util.fdialog.FGCallbackimport com.fidilaundry.app.util.fdialog.SuccessMessageimport com.fidilaundry.app.util.setSafeOnClickListenerimport com.google.android.gms.location.FusedLocationProviderClientimport com.google.android.gms.location.LocationServicesimport com.mapbox.api.directions.v5.DirectionsCriteriaimport com.mapbox.api.directions.v5.MapboxDirectionsimport com.mapbox.api.directions.v5.models.DirectionsResponseimport com.mapbox.api.directions.v5.models.DirectionsRouteimport com.mapbox.core.constants.Constants.PRECISION_6import com.mapbox.geojson.Featureimport com.mapbox.geojson.FeatureCollectionimport com.mapbox.geojson.LineStringimport com.mapbox.geojson.Pointimport com.mapbox.mapboxsdk.Mapboximport com.mapbox.mapboxsdk.maps.MapboxMapimport com.mapbox.mapboxsdk.maps.OnMapReadyCallbackimport com.mapbox.mapboxsdk.maps.Styleimport com.mapbox.mapboxsdk.maps.Style.OnStyleLoadedimport com.mapbox.mapboxsdk.style.layers.LineLayerimport com.mapbox.mapboxsdk.style.layers.Propertyimport com.mapbox.mapboxsdk.style.layers.PropertyFactory.*import com.mapbox.mapboxsdk.style.layers.SymbolLayerimport com.mapbox.mapboxsdk.style.sources.GeoJsonSourceimport com.mapbox.mapboxsdk.utils.BitmapUtilsimport org.koin.androidx.viewmodel.ext.android.getViewModelimport retrofit2.Callimport retrofit2.Callbackimport retrofit2.Responseimport timber.log.Timberimport java.util.concurrent.TimeUnitclass AdminOrderMapsActivity : BaseActivity() {    lateinit var loadingDialog: LoadingDialog//    var mapView: MapView? = null    private val ROUTE_LAYER_ID = "route-layer-id"    private val ROUTE_SOURCE_ID = "route-source-id"    private val ICON_LAYER_ID = "icon-layer-id"    private val ICON_SOURCE_ID = "icon-source-id"    private val RED_PIN_ICON_ID = "red-pin-icon-id"    lateinit var currentRoute: DirectionsRoute    lateinit var client: MapboxDirections    lateinit var origin: Point    lateinit var destination: Point    private var orderId: Int = 0    private var code: String = ""    private var data: OrderListResponse.Result? = null    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient    private var longitude = 0.0    private var latitude = 0.0    private var isUpdate = false    private val binding: ActivityAdminOrderMapsBinding by binding(R.layout.activity_admin_order_maps)    private val viewModel: TrackingViewModel by lazy {        getViewModel(TrackingViewModel::class)    }    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        Mapbox.getInstance(applicationContext, getString(R.string.mapbox_access_token))        binding.apply {            lifecycleOwner = this@AdminOrderMapsActivity            this.vm = viewModel        }        loadingDialog = LoadingDialog()        data = intent.getSerializableExtra("data") as OrderListResponse.Result        orderId = data?.id!!        code = data?.code!!        binding.tvAddress.text = data?.addressDescription//        orderId = intent.getIntExtra("orderId", 0)//        code = intent.getStringExtra("code").toString()//        binding.mapView.getMapboxMap()?.loadStyleUri(Style.MAPBOX_STREETS)        fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this)        checkPermission()        binding.mapView.onCreate(savedInstanceState)        initMaps()        initViewModel()        binding.ivBack.setSafeOnClickListener {            finish()        }        binding.btnUpdate.setSafeOnClickListener {            isUpdate = true            checkPermission()//            viewModel.addTracking(AddTrackingRequest(//                orderId, latitude.toString(), longitude.toString(), viewModel.desc.value//            ))        }        binding.btnDone.setSafeOnClickListener {            viewModel.updateOrderStatus(UpdateOrderStatusRequest(                code, StatusHelper.setStatus("dijemput"), ""            ))        }    }    private fun checkPermission() {        if (ActivityCompat.checkSelfPermission(                this,                Manifest.permission.ACCESS_FINE_LOCATION            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(                this,                Manifest.permission.ACCESS_COARSE_LOCATION            ) != PackageManager.PERMISSION_GRANTED        ) {            ActivityCompat.requestPermissions(                this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),                1            )            return        } else {            fusedLocationProviderClient.lastLocation.addOnSuccessListener { location ->                if (location != null) {                    val geoCoder = Geocoder(this)                    val currentLocation = geoCoder.getFromLocation(                        location.latitude,                        location.longitude,                        1                    )                    println("omgggg lat: "+currentLocation.first().latitude)                    println("omgggg long: "+currentLocation.first().longitude)                    println("omgggg address: "+currentLocation.first().getAddressLine(0))                    latitude = currentLocation.first().latitude                    longitude = currentLocation.first().longitude                    initMaps()                    if (isUpdate) {                        viewModel.addTracking(AddTrackingRequest(                            orderId, latitude.toString(), longitude.toString(), viewModel.desc.value                        ))                    }                }            }        }    }    private fun initMaps() {        // Setup the MapView        binding.mapView.getMapAsync(object : OnMapReadyCallback {            override fun onMapReady(@NonNull mapboxMap: MapboxMap) {                mapboxMap.setStyle(Style.MAPBOX_STREETS,                    OnStyleLoaded { style ->                        origin = Point.fromLngLat( longitude, latitude)                        destination = Point.fromLngLat(                            (if (data?.longitude == "") 112.7102763 else data?.longitude?.toDouble())!!,                            (if (data?.latitude == "") -7.4568788 else data?.latitude?.toDouble())!!                        )                        initSource(style!!)                        initLayers(style)                        // Get the directions route from the Mapbox Directions API                        getRoute(mapboxMap, origin, destination)                    })            }        })    }    private fun initSource(loadedMapStyle: Style) {        loadedMapStyle.addSource(GeoJsonSource(ROUTE_SOURCE_ID))        val iconGeoJsonSource = GeoJsonSource(            ICON_SOURCE_ID, FeatureCollection.fromFeatures(                arrayOf<Feature>(                    Feature.fromGeometry(                        Point.fromLngLat(                            origin!!.longitude(),                            origin!!.latitude()                        )                    ),                    Feature.fromGeometry(                        Point.fromLngLat(                            destination!!.longitude(),                            destination!!.latitude()                        )                    )                )            )        )        loadedMapStyle.addSource(iconGeoJsonSource)    }    private fun initLayers(loadedMapStyle: Style) {        val routeLayer = LineLayer(ROUTE_LAYER_ID, ROUTE_SOURCE_ID)        // Add the LineLayer to the map. This layer will display the directions route.        routeLayer.setProperties(            lineCap(Property.LINE_CAP_ROUND),            lineJoin(Property.LINE_JOIN_ROUND),            lineWidth(5f),            lineColor(Color.parseColor("#009688"))        )        loadedMapStyle.addLayer(routeLayer)        // Add the red marker icon image to the map        loadedMapStyle.addImage(            RED_PIN_ICON_ID, BitmapUtils.getBitmapFromDrawable(                resources.getDrawable(R.drawable.ic_marker_cust)            )!!        )        // Add the red marker icon SymbolLayer to the map        loadedMapStyle.addLayer(            SymbolLayer(ICON_LAYER_ID, ICON_SOURCE_ID).withProperties(                iconImage(RED_PIN_ICON_ID),                iconIgnorePlacement(true),                iconAllowOverlap(true),                iconOffset(arrayOf<Float>(0f, -9f))            )        )    }    private fun getRoute(mapboxMap: MapboxMap?, origin: Point, destination: Point) {        client = MapboxDirections.builder()            .origin(origin)            .destination(destination)            .overview(DirectionsCriteria.OVERVIEW_FULL)            .profile(DirectionsCriteria.PROFILE_DRIVING)            .accessToken(getString(R.string.mapbox_access_token))            .build()        client.enqueueCall(object : Callback<DirectionsResponse?> {            override fun onResponse(                call: Call<DirectionsResponse?>,                response: Response<DirectionsResponse?>            ) {                // You can get the generic HTTP info about the response                Timber.d("Response code: " + response.code())                if (response.body() == null) {                    Timber.e("No routes found, make sure you set the right user and access token.")                    return                } else if (response.body()!!.routes().size < 1) {                    Timber.e("No routes found")                    return                }                // Get the directions route                currentRoute = response.body()!!.routes().get(0)                var directiontime = TimeUnit.SECONDS.toMinutes(currentRoute.duration().toLong())                binding.tvTimeDistance.text = "${currentRoute.distance()} - ${directiontime} m"                mapboxMap?.getStyle(OnStyleLoaded { style ->                    // Retrieve and update the source designated for showing the directions route                    val source = style.getSourceAs<GeoJsonSource>(ROUTE_SOURCE_ID)                    // Create a LineString with the directions route's geometry and                    // reset the GeoJSON source for the route LineLayer source                    source?.setGeoJson(                        LineString.fromPolyline(                            currentRoute.geometry()!!,                            PRECISION_6                        )                    )                })            }            override fun onFailure(call: Call<DirectionsResponse?>, t: Throwable) {                Timber.e("Error: " + t.message)                Toast.makeText(                    this@AdminOrderMapsActivity, "Error: " + t.message,                    Toast.LENGTH_SHORT                ).show()            }        })    }    private fun initViewModel() {        viewModel.addTrackResponse.observe(this, Observer {            handleWhenAddTrackSuccess(it)        })        viewModel.updateOrderStatusResponse.observe(this, Observer {            handleWhenUpdateStatusSuccess(it)        })        viewModel.showProgressLiveData.observe(this, Observer { showLoading ->            if (showLoading) {                if(loadingDialog != null){                    if(!loadingDialog.isShowLoad())                        loadingDialog.showProgressDialog(this, "Mohon tunggu…")                    else {                        loadingDialog.dismissDialog()                        loadingDialog.showProgressDialog(this, "Mohon tunggu…")                    }                }            } else {                loadingDialog.dismissDialog()            }        })        viewModel.showError.observe(this, Observer { showError ->            ErrorMessage(this, "", showError)        })    }    private fun handleWhenUpdateStatusSuccess(it: UpdateStatusResponse?) {        // redirect update item        val intent = Intent(this@AdminOrderMapsActivity, AdminOrderActivity::class.java)        intent.putExtra("transId", it?.results?.orderCode)        intent.putExtra("serviceId", it?.results?.serviceID)        startActivity(intent)        finish()    }    private fun handleWhenAddTrackSuccess(it: BaseResponse?) {        SuccessMessage(this, "", "Berhasil tersimpan!", object : FGCallback {            override fun onCallback() {            }        })    }    override fun onRequestPermissionsResult(        requestCode: Int,        permissions: Array<String?>,        grantResults: IntArray    ) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults)        if (requestCode == 1) {            checkPermission()        }    }    override fun onStart() {        super.onStart()        binding.mapView.onStart()    }    override fun onStop() {        super.onStop()        binding.mapView.onStop()    }    override fun onLowMemory() {        super.onLowMemory()        binding.mapView.onLowMemory()    }    override fun onDestroy() {        super.onDestroy()        binding.mapView.onDestroy()    }}